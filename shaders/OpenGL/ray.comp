#version 450

layout(local_size_x = 8, local_size_y = 8) in;

#define PI 			3.1415926535
#define MAXFLOAT	99999.99

#define MAXDEPTH 	5
#define NUMSAMPLES 	4

uniform layout(binding = 0, rgba32f) image2D outputTexture;

struct Sphere {
    vec3 position;
    float radius;
    vec3 color;
};

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Camera {
    vec3 origin;
    vec3 lowerLeftCorner;
    vec3 horizontal;
    vec3 vertical;
    vec3 u, v, w;
    float lensRadius;
};

bool hitSphere(Ray ray, Sphere sphere, float t_min, float t_max, out float t_out) {
    // analytical solution
    vec3 oc = ray.origin - sphere.position;
    float a = dot(ray.direction, ray.direction);
    float b = dot(oc, ray.direction);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;

    float discriminant = b * b - a * c;

    if (discriminant > 0.0f) {
        if(b > 0) 
            t_out = (-b + sqrt(discriminant)) / a;
        else 
            t_out = (-b - sqrt(discriminant)) / a;
        
        if(t_out < t_max && t_out > t_min) {
            return true;
        }
    }

    // Geometric solution
    // float R2 = sphere.radius * sphere.radius;
    // vec3 L = sphere.position - ray.origin;
    // float tca = dot(L, normalize(ray.direction));
    // if(tca < 0) return false;

    // float D2 = dot(L, L) - tca * tca;
    // if(D2 > R2) return false;
    // float thc = sqrt(R2 - D2);
    // float t0 = tca - thc;
    // float t1 = tca + thc;

    // if(t0 < t_max && t0 > t_min) {
    //     t_out = t0;
    //     return true;
    // }

    // if(t1 < t_max && t1 > t_min) {
    //     t_out = t1;
    //     return true;
    // }
    
    return false; 
}

// random number generator
vec2 randState;

float hash( const float n )  {
     return fract(sin(n)*43758.54554213);
}


float rand2D() {
    randState.x = fract(sin(dot(randState.xy, vec2(12.9898, 78.233))) * 43758.5453);
    randState.y = fract(sin(dot(randState.xy, vec2(12.9898, 78.233))) * 43758.5453);;
    
    return randState.x;
}

// random point on unit disk (for depth of field camera)
vec3 random_in_unit_disk() {
    float spx = 2.0 * rand2D() - 1.0;
    float spy = 2.0 * rand2D() - 1.0;

    float r, phi;

    if(spx > -spy) {
        if(spx > spy) {
            r = spx;
            phi = spy / spx;
        } else {
            r = spy;
            phi = 2.0 - spx / spy;
        }
    } else {
        if(spx < spy) {
            r = -spx;
            phi = 4.0f + spy / spx;
        }
        else {
            r = -spy;

            if(spy != 0.0) 
                phi = 6.0 - spx / spy;
            else 
                phi = 0.0;
        }
    }

    phi *= PI / 4.0;

    return vec3(r * cos(phi), r * sin(phi), 0.0f);
}


// vfov is top to bottom in degrees
void Camera_init(out Camera camera, vec3 lookfrom, vec3 lookat, vec3 vup, float vfov, float aspect, float aperture, float focusDist) {
    camera.lensRadius = aperture / 2.0;
    
    float theta = vfov * PI / 180.0;
    float halfHeight = tan(theta / 2.0);
    float halfWidth = aspect * halfHeight;

    camera.origin = lookfrom;

    camera.w = normalize(lookfrom - lookat);
    camera.u = normalize(cross(vup, camera.w));
    camera.v = cross(camera.w, camera.u);

    camera.lowerLeftCorner = camera.origin  - halfWidth  * focusDist * camera.u
                                            - halfHeight * focusDist * camera.v
                                            -              focusDist * camera.w;

    camera.horizontal = 2.0 * halfWidth  * focusDist * camera.u;
    camera.vertical   = 2.0 * halfHeight * focusDist * camera.v;
}

Ray Camera_getRay(Camera camera, float s, float t) {
    vec3 rd = camera.lensRadius * random_in_unit_disk();
    vec3 offset = camera.u * rd.x + camera.v * rd.y;

    Ray ray;

    ray.origin = camera.origin + offset;
    ray.direction = camera.lowerLeftCorner + s * camera.horizontal + t * camera.vertical - camera.origin - offset;

    return ray;
}


// random direction in unit sphere (for lambert brdf)
vec3 random_in_unit_sphere() {
    float phi = 2.0 * PI * rand2D();
    float cosTheta = 2.0 * rand2D() - 1.0;
    float u = rand2D();

    float theta = acos(cosTheta);
    float r = pow(u, 1.0 / 3.0);

    float x = r * sin(theta) * cos(phi);
    float y = r * sin(theta) * sin(phi);
    float z = r * cos(theta);

    return vec3(x, y, z);
}

bool MaterialBsdf(Sphere sphere, float t, Ray wo, out Ray wi, out vec3 attenuation) {
    vec3 p = wo.origin + wo.direction * t;
    vec3 n = normalize(p - sphere.position);
    vec3 target = p + n + random_in_unit_sphere();

    wi.origin = p;
    wi.direction = target - p;
    attenuation = sphere.color;
    return true;
}

bool get_closest_sphere_hit(Ray ray, Sphere world[2], float t_min, float t_max, out Sphere closest_sphere_hit, out float closest_so_far) {
    float p_temp;
    
    bool hit_anything = false;
    closest_so_far = t_max;

    for(int i = 0; i < world.length(); i++) {
        if(hitSphere(ray, world[i], t_min, t_max, p_temp)) {
            closest_so_far = p_temp < closest_so_far ? p_temp : closest_so_far;
            closest_sphere_hit = world[i];
            hit_anything = true;
        }
    }

    return hit_anything;
}

vec3 sky_gradient(Ray ray) {
    vec3 unit_direction = normalize(ray.direction);
    float t = 0.5 * (unit_direction.y + 1.0);

    return (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0);
}

vec3 rayTraceWorld(Ray ray, Sphere world[2]) {
    vec3 color = vec3(1.0, 1.0, 1.0);

    float t;
    Sphere closest_sphere_hit;

    for(int i = 0; i < MAXDEPTH; i++) {
        if(get_closest_sphere_hit(ray, world, 0.001, MAXFLOAT, closest_sphere_hit, t)) {

            Ray wi;
            vec3 attenuation;
            bool scattered = MaterialBsdf(closest_sphere_hit, t, ray, wi, attenuation);

            ray.origin = wi.origin;
            ray.direction = wi.direction;

            if(scattered) {
                color *= attenuation;
            } else {
                color *= vec3(0, 0, 0);
                break;
            }

        } else {
            color *= sky_gradient(ray);
            break;
        }
    }

    return color;
}

void main() {
    Sphere world[] = Sphere[2](
        Sphere(vec3(0, -1000, 0), 1000, vec3(0.5, 0.5, 0.5)),
        Sphere(vec3(0.000000, 1.000000, 0.000000), 1.0, vec3(0.400000, 0.200000, 0.100000))
    );
    
    vec2 iResolution = imageSize(outputTexture);
    ivec2 fragCoord = ivec2(gl_GlobalInvocationID.xy);

    vec3 lookFrom = vec3(13.0, 2.0, 3.0);
    const vec3 lookAt = vec3(0, 0, 0);
    float distToFocus = 10;
    float aperture = 0.1;

    Camera camera;
    Camera_init(camera, lookFrom, lookAt, vec3(0, 1, 0), 20.0f, float(iResolution.x) / float(iResolution.y), aperture, distToFocus);

    randState = fragCoord.xy / iResolution.xy;
    
    vec3 color = vec3(0, 0, 0);

    for(int s = 0; s < NUMSAMPLES; s++) {
        float u = float(fragCoord.x + rand2D()) / float(iResolution.x);
        float v = float(fragCoord.y + rand2D()) / float(iResolution.y);

        Ray ray = Camera_getRay(camera, u, v);
        color += rayTraceWorld(ray, world);
    }

    color /= float(NUMSAMPLES);
    color = vec3(sqrt(color[0]), sqrt(color[1]), sqrt(color[2]));

    imageStore(outputTexture, fragCoord, vec4(color, 1.0));
}