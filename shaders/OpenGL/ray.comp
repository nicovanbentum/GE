#version 450

layout(local_size_x = 8, local_size_y = 8) in;

#define PI 			3.1415926535
#define MAXFLOAT	99999.99

#define MAXDEPTH 	5
#define NUMSAMPLES 	4

#define RANGE uvec4(65535u)
#define MAX_RANDOM float(RANGE-1u)

layout(binding = 0, rgba32f) uniform image2D outputTexture;
layout(binding = 1, rgba32f) uniform image2D finalTexture;

vec2 iResolution = imageSize(outputTexture);
ivec2 fragCoord = ivec2(gl_GlobalInvocationID.xy);

uniform float iTime;

uniform vec3 position;
uniform mat4 view;
uniform mat4 projection;
uniform bool doUpdate;

const uint ROUGH = 0;
const uint REFLECT = 1;

struct Material {
    vec3 color;
    uint type;
};

struct Sphere {
    vec3 position;
    float radius;
    Material material;
};

struct Ray {
    vec3 origin;
    vec3 direction;
};

bool hitSphere(Ray ray, Sphere sphere, float t_min, float t_max, out float t_out) {
    // Geometric solution
    float R2 = sphere.radius * sphere.radius;
    vec3 L = sphere.position - ray.origin;
    float tca = dot(L, normalize(ray.direction));
    if(tca < 0) return false;

    float D2 = dot(L, L) - tca * tca;
    if(D2 > R2) return false;
    float thc = sqrt(R2 - D2);
    float t0 = tca - thc;
    float t1 = tca + thc;

    if(t0 < t_max && t0 > t_min) {
        t_out = t0 / length(ray.direction);
        return true;
    }

    if(t1 < t_max && t1 > t_min) {
        t_out = t1 / length(ray.direction);
        return true;
    }
    
    return false; 
}


// Noise generation from https://www.shadertoy.com/view/MtycWc
// https://merlin3d.wordpress.com/2018/10/04/correlated-multi-jittered-sampling-on-gpu/
// Generate an unsigned integer random vector in the range of [0..range-1]^3 
// with uniform distribution from a linear seed using mixing functions.
// Maximum valid value of range is 65535.
uvec4 rand ( uvec4 s, uvec4 range ) {
    s ^= uvec4(s.x >> 19, s.y >> 19, s.z >> 13, s.w >> 19);
    s *= uvec4(1619700021, 3466831627, 923620057, 3466831627);
    s ^= uvec4(s.x >> 16, s.y >> 12, s.z >> 18, s.w >> 17);
    s *= uvec4(175973783, 2388179301, 3077236438, 2388179301);
    s ^= uvec4(s.x >> 15, s.y >> 17, s.z >> 18, s.w >> 18);
    
    uvec4 f = s >> 16;
    return (range * f + (s % range)) >> 16;    
}

uvec4 seed ( in vec2 fragCoord, in vec2 iResolution, in float iTime ) {
    float fseed = fragCoord.x + fragCoord.y * iResolution.x + 1.0 + mod(iTime, 16.0f) * iResolution.x * iResolution.y;
    return uvec4(fseed);
}

// return a random point on or inside the unit sphere
vec3 sampleUnitSphere ( inout uvec4 useed ) {
    useed = rand(useed, RANGE);
    vec3 noise3 = vec3(useed.xyz) / MAX_RANDOM - .5;
    float noise = float(useed.w) / MAX_RANDOM;
    return normalize(noise3) * noise;
}

vec3 randomInHemisphere(vec3 n, inout uvec4 useed) {
    vec3 inUnitSphere = sampleUnitSphere(useed);
    if(dot(inUnitSphere, n) > 0.0) {
        return inUnitSphere;
    } else {
        return -inUnitSphere;
    }
}

// return a random point on a unit disk
vec3 sampleUnitDisk ( inout uvec4 useed ) {
    useed = rand(useed, RANGE);
    vec3 noise3 = vec3(useed.xyz) / MAX_RANDOM - .5;
    float noise = float(useed.w) / MAX_RANDOM;
    return vec3((normalize(noise3) * noise).xy, 0);
}

Ray Camera_getRay(inout uvec4 useed) {
    vec3 rayNDC = vec3(
        (2.0f * fragCoord.x) / iResolution.x - 1.0f,
        1.0f - (2.0f * fragCoord.y) / iResolution.y,
        1.0f
    );

    vec4 rayClip = vec4( rayNDC.x, rayNDC.y * -1, -1.0f, 1.0f );

    vec4 rayCamera = inverse(projection) * rayClip;
    rayCamera.z = -1.0f, rayCamera.w = 0.0f;

    vec3 direction = normalize((inverse(view) * rayCamera).xyz);

    return Ray(position, direction);
}

bool MaterialBsdf(Sphere sphere, float t, Ray wo, out Ray wi, out vec3 attenuation, inout uvec4 useed) {
    vec3 p = wo.origin + wo.direction * t;
    vec3 n = normalize(p - sphere.position);

    vec3 target;
    if(sphere.material.type == ROUGH) {
        target = p + randomInHemisphere(n, useed);
    } else if(sphere.material.type == REFLECT) {
        target = p + reflect(normalize(wo.direction), n);
    }

    wi.origin = p;
    wi.direction = target - p;
    attenuation = sphere.material.color;

    return (dot(wi.direction, n) > 0.0);
}

bool get_closest_sphere_hit(Ray ray, Sphere world[3], float t_min, float t_max, out Sphere closest_sphere_hit, out float closest_so_far) {
    float p_temp;
    
    bool hit_anything = false;
    closest_so_far = t_max;

    for(int i = 0; i < world.length(); i++) {
        if(hitSphere(ray, world[i], t_min, t_max, p_temp)) {
            closest_so_far = p_temp < closest_so_far ? p_temp : closest_so_far;
            closest_sphere_hit = world[i];
            hit_anything = true;
        }
    }

    return hit_anything;
}

vec3 sky_gradient(Ray ray) {
    vec3 unit_direction = normalize(ray.direction);
    float t = 0.5 * (unit_direction.y + 1.0);

    return (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0);
}

vec3 rayTraceWorld(Ray ray, Sphere world[3], inout uvec4 useed) {
    vec3 color = vec3(1.0, 1.0, 1.0);

    float t;
    Sphere closest_sphere_hit;

    for(int i = 0; i < MAXDEPTH; i++) {
        if(get_closest_sphere_hit(ray, world, 0.001, 10000.0, closest_sphere_hit, t)) {

            Ray wi;
            vec3 attenuation;
            bool scattered = MaterialBsdf(closest_sphere_hit, t, ray, wi, attenuation, useed);

            ray.origin = wi.origin;
            ray.direction = wi.direction;

            if(scattered) {
                color *= attenuation;
            } else {
                color *= vec3(0, 0, 0);
                break;
            }

        } else {
            color *= sky_gradient(ray);
            break;
        }
    }

    return color;
}

void main() {
    Sphere world[] = Sphere[3] (
        Sphere(vec3(0, -1000, 0), 1000, Material( vec3(0.5, 0.5, 0.5), ROUGH)),
        Sphere(vec3(0.000000, 1.000000, 0.000000), 1.0, Material(vec3(0.900000, 0.900000, 0.100000), ROUGH)),
        Sphere(vec3(1.000000, 1.000000, 2.000000), 1.0, Material(vec3(0.400000, 0.600000, 0.450000), REFLECT))
    );
    

    vec3 lookFrom = vec3(13.0, 2.0, 3.0);
    const vec3 lookAt = vec3(0, 0, 0);
    float distToFocus = 10;
    float aperture = 0.1;

    vec3 color = vec3(0, 0, 0);

    uvec4 useed = seed(fragCoord, iResolution, iTime);

    for(int s = 0; s < NUMSAMPLES; s++) {
        useed = rand(useed, RANGE);
        vec2 noise2 = vec2(useed.xy) / MAX_RANDOM - 0.5;
        float u = float(fragCoord.x + noise2.x) / float(iResolution.x);
        float v = float(fragCoord.y + noise2.y) / float(iResolution.y);

        Ray ray = Camera_getRay(useed);
        color += rayTraceWorld(ray, world, useed);
    }

    color /= float(NUMSAMPLES);

    if(doUpdate) {
        vec4 currentColor = imageLoad(outputTexture, fragCoord);
        imageStore(outputTexture, fragCoord, currentColor + vec4(color, 1.0));

        vec4 accumulatedColor = imageLoad(outputTexture, fragCoord);
        imageStore(finalTexture, fragCoord, vec4(sqrt(accumulatedColor.rgb / accumulatedColor.w), 1.0));
    } else {
        imageStore(finalTexture, fragCoord, vec4(sqrt(color), 1.0));
    }

}